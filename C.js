// Do not edit this file; automatically generated by gulp.
'use strict';


Blockly.C = new Blockly.Generator("C");
Blockly.C.addReservedWords("break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,enum,implements,interface,let,package,private,protected,public,static,await,null,true,false,arguments," + Object.getOwnPropertyNames(Blockly.utils.global).join(","));
Blockly.C.ORDER_ATOMIC = 0;
Blockly.C.ORDER_NEW = 1.1;
Blockly.C.ORDER_MEMBER = 1.2;
Blockly.C.ORDER_FUNCTION_CALL = 2;
Blockly.C.ORDER_INCREMENT = 3;
Blockly.C.ORDER_DECREMENT = 3;
Blockly.C.ORDER_BITWISE_NOT = 4.1;
Blockly.C.ORDER_UNARY_PLUS = 4.2;
Blockly.C.ORDER_UNARY_NEGATION = 4.3;
Blockly.C.ORDER_LOGICAL_NOT = 4.4;
Blockly.C.ORDER_TYPEOF = 4.5;
Blockly.C.ORDER_VOID = 4.6;
Blockly.C.ORDER_DELETE = 4.7;
Blockly.C.ORDER_AWAIT = 4.8;
Blockly.C.ORDER_EXPONENTIATION = 5;
Blockly.C.ORDER_MULTIPLICATION = 5.1;
Blockly.C.ORDER_DIVISION = 5.2;
Blockly.C.ORDER_MODULUS = 5.3;
Blockly.C.ORDER_SUBTRACTION = 6.1;
Blockly.C.ORDER_ADDITION = 6.2;
Blockly.C.ORDER_BITWISE_SHIFT = 7;
Blockly.C.ORDER_RELATIONAL = 8;
Blockly.C.ORDER_IN = 8;
Blockly.C.ORDER_INSTANCEOF = 8;
Blockly.C.ORDER_EQUALITY = 9;
Blockly.C.ORDER_BITWISE_AND = 10;
Blockly.C.ORDER_BITWISE_XOR = 11;
Blockly.C.ORDER_BITWISE_OR = 12;
Blockly.C.ORDER_LOGICAL_AND = 13;
Blockly.C.ORDER_LOGICAL_OR = 14;
Blockly.C.ORDER_CONDITIONAL = 15;
Blockly.C.ORDER_ASSIGNMENT = 16;
Blockly.C.ORDER_YIELD = 17;
Blockly.C.ORDER_COMMA = 18;
Blockly.C.ORDER_NONE = 99;
Blockly.C.ORDER_OVERRIDES = [
    [Blockly.C.ORDER_FUNCTION_CALL, Blockly.C.ORDER_MEMBER],
    [Blockly.C.ORDER_FUNCTION_CALL, Blockly.C.ORDER_FUNCTION_CALL],
    [Blockly.C.ORDER_MEMBER, Blockly.C.ORDER_MEMBER],
    [Blockly.C.ORDER_MEMBER, Blockly.C.ORDER_FUNCTION_CALL],
    [Blockly.C.ORDER_LOGICAL_NOT, Blockly.C.ORDER_LOGICAL_NOT],
    [Blockly.C.ORDER_MULTIPLICATION, Blockly.C.ORDER_MULTIPLICATION],
    [Blockly.C.ORDER_ADDITION,
        Blockly.C.ORDER_ADDITION
    ],
    [Blockly.C.ORDER_LOGICAL_AND, Blockly.C.ORDER_LOGICAL_AND],
    [Blockly.C.ORDER_LOGICAL_OR, Blockly.C.ORDER_LOGICAL_OR]
];
Blockly.C.init = function(a) {
    Blockly.C.definitions_ = Object.create(null);
    Blockly.C.functionNames_ = Object.create(null);
    Blockly.C.variableDB_ ? Blockly.C.variableDB_.reset() : Blockly.C.variableDB_ = new Blockly.Names(Blockly.C.RESERVED_WORDS_);
    Blockly.C.variableDB_.setVariableMap(a.getVariableMap());
    for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) b.push(Blockly.C.variableDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
    a = Blockly.Variables.allUsedVarModels(a);
    var mapVar=[];
    for (d = 0; d < a.length; d++) 
        {
            if(mapVar[a[d].type]==undefined)
                mapVar[a[d].type]=[Blockly.C.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME)];
            else
                mapVar[a[d].type].push(Blockly.C.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME));
            b.push([Blockly.C.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME),a[d].type]);
        }
    var dec="";
    //console.log(mapVar);

    Object.keys(mapVar).forEach((key,index)=>{
        //if(key.indexOf("[]")==-1)
        dec+= key+" "+mapVar[key].join(",")+";\n";
    });
        console.log(a);
        console.log(dec);
        console.log(mapVar);
        var declaration ="";

        for(var z=0;z<b.length;z++)
            declaration+= b[z][1] +" "+b[z][0]+";";
        console.log(declaration);
        
    b.length && (Blockly.C.definitions_.variables = dec);
};

Blockly.C.finish = function(a) {
    var b = [],
        c;
    for (c in Blockly.C.definitions_) b.push(Blockly.C.definitions_[c]);
    delete Blockly.C.definitions_;
    delete Blockly.C.functionNames_;
    Blockly.C.variableDB_.reset();
    return b.join("\n\n") + "\n\n\n" + a
};
Blockly.C.scrubNakedValue = function(a) {
    return a + ";\n"
};
Blockly.C.quote_ = function(a) {
    a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/'/g, "\\'");
    return "'" + a + "'"
};
Blockly.C.multiline_quote_ = function(a) {
    return a.split(/\n/g).map(Blockly.C.quote_).join(" + '\\n' +\n")
};
Blockly.C.scrub_ = function(a, b, c) {
    var d = "";
    if (!a.outputConnection || !a.outputConnection.targetConnection) {
        var e = a.getCommentText();
        e && (e = Blockly.utils.string.wrap(e, Blockly.C.COMMENT_WRAP - 3), d += Blockly.C.prefixLines(e + "\n", "// "));
        for (var f = 0; f < a.inputList.length; f++) a.inputList[f].type == Blockly.INPUT_VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = Blockly.C.allNestedComments(e)) && (d += Blockly.C.prefixLines(e, "// "))
    }
    a = a.nextConnection && a.nextConnection.targetBlock();
    c = c ? "" : Blockly.C.blockToCode(a);
    return d + b + c
};
Blockly.C.getAdjusted = function(a, b, c, d, e) {
    c = c || 0;
    e = e || Blockly.C.ORDER_NONE;
    a.workspace.options.oneBasedIndex && c--;
    var f = a.workspace.options.oneBasedIndex ? "1" : "0";
    a = 0 < c ? Blockly.C.valueToCode(a, b, Blockly.C.ORDER_ADDITION) || f : 0 > c ? Blockly.C.valueToCode(a, b, Blockly.C.ORDER_SUBTRACTION) || f : d ? Blockly.C.valueToCode(a, b, Blockly.C.ORDER_UNARY_NEGATION) || f : Blockly.C.valueToCode(a, b, e) || f;
    if (Blockly.isNumber(a)) a = Number(a) + c, d &&
        (a = -a);
    else {
        if (0 < c) {
            a = a + " + " + c;
            var g = Blockly.C.ORDER_ADDITION
        } else 0 > c && (a = a + " - " + -c, g = Blockly.C.ORDER_SUBTRACTION);
        d && (a = c ? "-(" + a + ")" : "-" + a, g = Blockly.C.ORDER_UNARY_NEGATION);
        g = Math.floor(g);
        e = Math.floor(e);
        g && e >= g && (a = "(" + a + ")")
    }
    return a
};
Blockly.C.colour = {};
Blockly.C.colour_picker = function(a) {
    return [Blockly.C.quote_(a.getFieldValue("COLOUR")), Blockly.C.ORDER_ATOMIC]
};
Blockly.C.colour_random = function(a) {
    return [Blockly.C.provideFunction_("colourRandom", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "() {", "  var num = Math.floor(Math.random() * Math.pow(2, 24));", "  return '#' + ('00000' + num.toString(16)).substr(-6);", "}"]) + "()", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.colour_rgb = function(a) {
    var b = Blockly.C.valueToCode(a, "RED", Blockly.C.ORDER_COMMA) || 0,
        c = Blockly.C.valueToCode(a, "GREEN", Blockly.C.ORDER_COMMA) || 0;
    a = Blockly.C.valueToCode(a, "BLUE", Blockly.C.ORDER_COMMA) || 0;
    return [Blockly.C.provideFunction_("colourRgb", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b) {", "  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;", "  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;",
        "  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;", "  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);", "  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);", "  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;", "}"
    ]) + "(" + b + ", " + c + ", " + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.colour_blend = function(a) {
    var b = Blockly.C.valueToCode(a, "COLOUR1", Blockly.C.ORDER_COMMA) || "'#000000'",
        c = Blockly.C.valueToCode(a, "COLOUR2", Blockly.C.ORDER_COMMA) || "'#000000'";
    a = Blockly.C.valueToCode(a, "RATIO", Blockly.C.ORDER_COMMA) || .5;
    return [Blockly.C.provideFunction_("colourBlend", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(c1, c2, ratio) {", "  ratio = Math.max(Math.min(Number(ratio), 1), 0);", "  var r1 = parseInt(c1.substring(1, 3), 16);",
        "  var g1 = parseInt(c1.substring(3, 5), 16);", "  var b1 = parseInt(c1.substring(5, 7), 16);", "  var r2 = parseInt(c2.substring(1, 3), 16);", "  var g2 = parseInt(c2.substring(3, 5), 16);", "  var b2 = parseInt(c2.substring(5, 7), 16);", "  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);", "  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);", "  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);", "  r = ('0' + (r || 0).toString(16)).slice(-2);", "  g = ('0' + (g || 0).toString(16)).slice(-2);", "  b = ('0' + (b || 0).toString(16)).slice(-2);",
        "  return '#' + r + g + b;", "}"
    ]) + "(" + b + ", " + c + ", " + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists = {};
Blockly.C.lists_create_empty = function(a) {
    return ["[]", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.lists_create_with = function(a) {
    for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.C.valueToCode(a, "ADD" + c, Blockly.C.ORDER_COMMA) || "null";
    return ["{" + b.join(", ") + "}", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.lists_repeat = function(a) {
    //var b = Blockly.C.provideFunction_("listsRepeat", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(value, n) {", "  var array = [];", "  for (int i = 0; i < n; i++) {", "    array[i] = value;", "  }", "  return array;", "}"]),
       var c = Blockly.C.valueToCode(a, "ITEM", Blockly.C.ORDER_COMMA) || "0";
   var n= Blockly.C.valueToCode(a, "NUM", Blockly.C.ORDER_COMMA) || "0";
    return ["{[0..." + n + "]=" + c + "}", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_length = function(a) {
    var b=Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER)|| "[]";
        var code = "sizeOf("+b+")/sizeOf("+b+"[0])"
    return [code, Blockly.C.ORDER_MEMBER]
};
Blockly.C.lists_isEmpty = function(a) {
    var b=Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER)|| "[]";
    var code = "((sizeOf("+b+")/sizeOf("+b+"[0]))==0)"
    return [code, Blockly.C.ORDER_LOGICAL_NOT]
};
Blockly.C.lists_indexOf = function(a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.C.valueToCode(a, "FIND", Blockly.C.ORDER_NONE) || "''";
    b = (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "[]") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.C.ORDER_ADDITION] : [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_getIndex = function(a) {
    var b = a.getFieldValue("MODE") || "GET",
        c = a.getFieldValue("WHERE") || "FROM_START",
        d = Blockly.C.valueToCode(a, "VALUE", "RANDOM" == c ? Blockly.C.ORDER_COMMA : Blockly.C.ORDER_MEMBER) || "[]";
    switch (c) {
        case "FIRST":
            if ("GET" == b) return [d + "[0]", Blockly.C.ORDER_MEMBER];
            if ("GET_REMOVE" == b) return [d + ".shift()", Blockly.C.ORDER_MEMBER];
            if ("REMOVE" == b) return d + ".shift();\n";
            break;
        case "LAST":
            if ("GET" == b) return [d + ".slice(-1)[0]", Blockly.C.ORDER_MEMBER];
            if ("GET_REMOVE" == b) return [d + ".pop()", Blockly.C.ORDER_MEMBER];
            if ("REMOVE" == b) return d + ".pop();\n";
            break;
        case "FROM_START":
            a = Blockly.C.getAdjusted(a, "AT");
            if ("GET" == b) return [d + "[" + a + "]", Blockly.C.ORDER_MEMBER];
            if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.C.ORDER_FUNCTION_CALL];
            if ("REMOVE" == b) return d + ".splice(" + a + ", 1);\n";
            break;
        case "FROM_END":
            a = Blockly.C.getAdjusted(a, "AT", 1, !0);
            if ("GET" == b) return [d + ".slice(" + a + ")[0]", Blockly.C.ORDER_FUNCTION_CALL];
            if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.C.ORDER_FUNCTION_CALL];
            if ("REMOVE" == b) return d + ".splice(" + a + ", 1);";
            break;
        case "RANDOM":
            d = Blockly.C.provideFunction_("listsGetRandomItem", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(list, remove) {", "  var x = Math.floor(Math.random() * list.length);", "  if (remove) {", "    return list.splice(x, 1)[0];", "  } else {", "    return list[x];", "  }", "}"]) + "(" + d + ", " + ("GET" != b) + ")";
            if ("GET" == b || "GET_REMOVE" == b) return [d,
                Blockly.C.ORDER_FUNCTION_CALL
            ];
            if ("REMOVE" == b) return d + ";\n"
    }
    throw Error("Unhandled combination (lists_getIndex).");
};
Blockly.C.lists_setIndex = function(a) {
    function b() {
        if (c.match(/^\w+$/)) return "";
        var a = Blockly.C.variableDB_.getDistinctName("tmpList", Blockly.VARIABLE_CATEGORY_NAME),
            b = "var " + a + " = " + c + ";\n";
        c = a;
        return b
    }
    var c = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]",
        d = a.getFieldValue("MODE") || "GET",
        e = a.getFieldValue("WHERE") || "FROM_START",
        f = Blockly.C.valueToCode(a, "TO", Blockly.C.ORDER_ASSIGNMENT) || "null";
    switch (e) {
        case "FIRST":
            if ("SET" == d) return c +
                "[0] = " + f + ";\n";
            if ("INSERT" == d) return c + ".unshift(" + f + ");\n";
            break;
        case "LAST":
            if ("SET" == d) return a = b(), a + (c + "[" + c + ".length - 1] = " + f + ";\n");
            if ("INSERT" == d) return c + ".push(" + f + ");\n";
            break;
        case "FROM_START":
            e = Blockly.C.getAdjusted(a, "AT");
            if ("SET" == d) return c + "[" + e + "] = " + f + ";\n";
            if ("INSERT" == d) return c + ".splice(" + e + ", 0, " + f + ");\n";
            break;
        case "FROM_END":
            e = Blockly.C.getAdjusted(a, "AT", 1, !1, Blockly.C.ORDER_SUBTRACTION);
            a = b();
            if ("SET" == d) return a + (c + "[" + c + ".length - " + e +
                "] = " + f + ";\n");
            if ("INSERT" == d) return a + (c + ".splice(" + c + ".length - " + e + ", 0, " + f + ");\n");
            break;
        case "RANDOM":
            a = b();
            e = Blockly.C.variableDB_.getDistinctName("tmpX", Blockly.VARIABLE_CATEGORY_NAME);
            a += "var " + e + " = Math.floor(Math.random() * " + c + ".length);\n";
            if ("SET" == d) return a + (c + "[" + e + "] = " + f + ";\n");
            if ("INSERT" == d) return a + (c + ".splice(" + e + ", 0, " + f + ");\n")
    }
    throw Error("Unhandled combination (lists_setIndex).");
};
Blockly.C.lists.getIndex_ = function(a, b, c) {
    return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c
};
Blockly.C.lists_getSublist = function(a) {
    var b = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2");
    if ("FIRST" == c && "LAST" == d) b += ".slice(0)";
    else if (b.match(/^\w+$/) || "FROM_END" != c && "FROM_START" == d) {
        switch (c) {
            case "FROM_START":
                var e = Blockly.C.getAdjusted(a, "AT1");
                break;
            case "FROM_END":
                e = Blockly.C.getAdjusted(a, "AT1", 1, !1, Blockly.C.ORDER_SUBTRACTION);
                e = b + ".length - " + e;
                break;
            case "FIRST":
                e =
                    "0";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist).");
        }
        switch (d) {
            case "FROM_START":
                a = Blockly.C.getAdjusted(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly.C.getAdjusted(a, "AT2", 0, !1, Blockly.C.ORDER_SUBTRACTION);
                a = b + ".length - " + a;
                break;
            case "LAST":
                a = b + ".length";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist).");
        }
        b = b + ".slice(" + e + ", " + a + ")"
    } else {
        e = Blockly.C.getAdjusted(a, "AT1");
        a = Blockly.C.getAdjusted(a, "AT2");
        var f = Blockly.C.lists.getIndex_,
            g = {
                FIRST: "First",
                LAST: "Last",
                FROM_START: "FromStart",
                FROM_END: "FromEnd"
            };
        b = Blockly.C.provideFunction_("subsequence" + g[c] + g[d], ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == c || "FROM_START" == c ? ", at1" : "") + ("FROM_END" == d || "FROM_START" == d ? ", at2" : "") + ") {", "  var start = " + f("sequence", c, "at1") + ";", "  var end = " + f("sequence", d, "at2") + " + 1;", "  return sequence.slice(start, end);", "}"]) + "(" + b + ("FROM_END" == c || "FROM_START" == c ? ", " + e : "") + ("FROM_END" == d || "FROM_START" ==
            d ? ", " + a : "") + ")"
    }
    return [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_sort = function(a) {
    var b = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_FUNCTION_CALL) || "[]",
        c = "1" === a.getFieldValue("DIRECTION") ? 1 : -1;
    a = a.getFieldValue("TYPE");
    var d = Blockly.C.provideFunction_("listsGetSortCompare", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(type, direction) {", "  var compareFuncs = {", '    "NUMERIC": function(a, b) {', "        return Number(a) - Number(b); },", '    "TEXT": function(a, b) {', "        return a.toString() > b.toString() ? 1 : -1; },",
        '    "IGNORE_CASE": function(a, b) {', "        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },", "  };", "  var compare = compareFuncs[type];", "  return function(a, b) { return compare(a, b) * direction; }", "}"
    ]);
    return [b + ".slice().sort(" + d + '("' + a + '", ' + c + "))", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_split = function(a) {
    var b = Blockly.C.valueToCode(a, "INPUT", Blockly.C.ORDER_MEMBER),
        c = Blockly.C.valueToCode(a, "DELIM", Blockly.C.ORDER_NONE) || "''";
    a = a.getFieldValue("MODE");
    if ("SPLIT" == a) b || (b = "''"), a = "split";
    else if ("JOIN" == a) b || (b = "[]"), a = "join";
    else throw Error("Unknown mode: " + a);
    return [b + "." + a + "(" + c + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_reverse = function(a) {
    return [(Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_FUNCTION_CALL) || "[]") + ".slice().reverse()", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.logic = {};
Blockly.C.controls_if = function(a) {
    var b = 0,
        c = "";
    Blockly.C.STATEMENT_PREFIX && (c += Blockly.C.injectId(Blockly.C.STATEMENT_PREFIX, a));
    do {
        var d = Blockly.C.valueToCode(a, "IF" + b, Blockly.C.ORDER_NONE) || "0";
        var e = Blockly.C.statementToCode(a, "DO" + b);
        Blockly.C.STATEMENT_SUFFIX && (e = Blockly.C.prefixLines(Blockly.C.injectId(Blockly.C.STATEMENT_SUFFIX, a), Blockly.C.INDENT) + e);
        c += (0 < b ? " else " : "") + "if (" +
            d + ") {\n" + e + "}";
        ++b
    } while (a.getInput("IF" + b));
    if (a.getInput("ELSE") || Blockly.C.STATEMENT_SUFFIX) e = Blockly.C.statementToCode(a, "ELSE"), Blockly.C.STATEMENT_SUFFIX && (e = Blockly.C.prefixLines(Blockly.C.injectId(Blockly.C.STATEMENT_SUFFIX, a), Blockly.C.INDENT) + e), c += " else {\n" + e + "}";
    return c + "\n"
};
Blockly.C.controls_ifelse = Blockly.C.controls_if;
Blockly.C.logic_compare = function(a) {
    var b = {
            EQ: "==",
            NEQ: "!=",
            LT: "<",
            LTE: "<=",
            GT: ">",
            GTE: ">="
        } [a.getFieldValue("OP")],
        c = "==" == b || "!=" == b ? Blockly.C.ORDER_EQUALITY : Blockly.C.ORDER_RELATIONAL,
        d = Blockly.C.valueToCode(a, "A", c) || "0";
    a = Blockly.C.valueToCode(a, "B", c) || "0";
    return [d + " " + b + " " + a, c]
};
Blockly.C.logic_operation = function(a) {
    var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
        c = "&&" == b ? Blockly.C.ORDER_LOGICAL_AND : Blockly.C.ORDER_LOGICAL_OR,
        d = Blockly.C.valueToCode(a, "A", c);
    a = Blockly.C.valueToCode(a, "B", c);
    if (d || a) {
        var e = "&&" == b ? "1" : "0";
        d || (d = e);
        a || (a = e)
    } else a = d = "0";
    return [d + " " + b + " " + a, c]
};
Blockly.C.logic_negate = function(a) {
    var b = Blockly.C.ORDER_LOGICAL_NOT;
    return ["!" + (Blockly.C.valueToCode(a, "BOOL", b) || "1"), b]
};
Blockly.C.logic_boolean = function(a) {
    return ["TRUE" == a.getFieldValue("BOOL") ? "1" : "0", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.logic_null = function(a) {
    return ["NULL", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.logic_ternary = function(a) {
    var b = Blockly.C.valueToCode(a, "IF", Blockly.C.ORDER_CONDITIONAL) || "0",
        c = Blockly.C.valueToCode(a, "THEN", Blockly.C.ORDER_CONDITIONAL) || "NULL";
    a = Blockly.C.valueToCode(a, "ELSE", Blockly.C.ORDER_CONDITIONAL) || "NULL";
    return [b + " ? " + c + " : " + a, Blockly.C.ORDER_CONDITIONAL]
};
Blockly.C.loops = {};
Blockly.C.controls_repeat_ext = function(a) {
    var b = a.getField("TIMES") ? String(Number(a.getFieldValue("TIMES"))) : Blockly.C.valueToCode(a, "TIMES", Blockly.C.ORDER_ASSIGNMENT) || "0",
        c = Blockly.C.statementToCode(a, "DO");
    c = Blockly.C.addLoopTrap(c, a);
    a = "";
    var d = Blockly.C.variableDB_.getDistinctName("i", Blockly.VARIABLE_CATEGORY_NAME),
        e = b;
    b.match(/^\w+$/) || Blockly.isNumber(b) || (e = Blockly.C.variableDB_.getDistinctName("repeat_end", Blockly.VARIABLE_CATEGORY_NAME),
        a += "var " + e + " = " + b + ";\n");
    return a + ("for (int " + d + " = 0; " + d + " < " + e + "; " + d + "++) {\n" + c + "}\n")
};
Blockly.C.controls_repeat = Blockly.C.controls_repeat_ext;
Blockly.C.controls_whileUntil = function(a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.C.valueToCode(a, "BOOL", b ? Blockly.C.ORDER_LOGICAL_NOT : Blockly.C.ORDER_NONE) || "0",
        d = Blockly.C.statementToCode(a, "DO");
    d = Blockly.C.addLoopTrap(d, a);
    b && (c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n"
};
Blockly.C.controls_for = function(a) {
    var b = Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
        c = Blockly.C.valueToCode(a, "FROM", Blockly.C.ORDER_ASSIGNMENT) || "0",
        d = Blockly.C.valueToCode(a, "TO", Blockly.C.ORDER_ASSIGNMENT) || "0",
        e = Blockly.C.valueToCode(a, "BY", Blockly.C.ORDER_ASSIGNMENT) || "1",
        f = Blockly.C.statementToCode(a, "DO");
    f = Blockly.C.addLoopTrap(f, a);
    if (Blockly.isNumber(c) && Blockly.isNumber(d) &&
        Blockly.isNumber(e)) {
        var g = Number(c) <= Number(d);
        a = "for (" + b + " = " + c + "; " + b + (g ? " <= " : " >= ") + d + "; " + b;
        b = Math.abs(Number(e));
        a = (1 == b ? a + (g ? "++" : "--") : a + ((g ? " += " : " -= ") + b)) + (") {\n" + f + "}\n")
    } else a = "", g = c, c.match(/^\w+$/) || Blockly.isNumber(c) || (g = Blockly.C.variableDB_.getDistinctName(b + "_start", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + g + " = " + c + ";\n"), c = d, d.match(/^\w+$/) || Blockly.isNumber(d) || (c = Blockly.C.variableDB_.getDistinctName(b + "_end", Blockly.VARIABLE_CATEGORY_NAME), a +=
        "var " + c + " = " + d + ";\n"), d = Blockly.C.variableDB_.getDistinctName(b + "_inc", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + d + " = ", a = Blockly.isNumber(e) ? a + (Math.abs(e) + ";\n") : a + ("Math.abs(" + e + ");\n"), a = a + ("if (" + g + " > " + c + ") {\n") + (Blockly.C.INDENT + d + " = -" + d + ";\n"), a += "}\n", a += "for (" + b + " = " + g + "; " + d + " >= 0 ? " + b + " <= " + c + " : " + b + " >= " + c + "; " + b + " += " + d + ") {\n" + f + "}\n";
    return a
};
Blockly.C.controls_forEach = function(a) {
    var b = Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
        c = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_ASSIGNMENT) || "[]",
        d = Blockly.C.statementToCode(a, "DO");
    d = Blockly.C.addLoopTrap(d, a);
    a = "";
    var e = c;
    c.match(/^\w+$/) || (e = Blockly.C.variableDB_.getDistinctName(b + "_list", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + e + " = " + c + ";\n");
    c = Blockly.C.variableDB_.getDistinctName(b +
        "_index", Blockly.VARIABLE_CATEGORY_NAME);
    d = Blockly.C.INDENT + b + " = " + e + "[" + c + "];\n" + d;
    return a + ("for (var " + c + " in " + e + ") {\n" + d + "}\n")
};
Blockly.C.controls_flow_statements = function(a) {
    var b = "";
    Blockly.C.STATEMENT_PREFIX && (b += Blockly.C.injectId(Blockly.C.STATEMENT_PREFIX, a));
    Blockly.C.STATEMENT_SUFFIX && (b += Blockly.C.injectId(Blockly.C.STATEMENT_SUFFIX, a));
    if (Blockly.C.STATEMENT_PREFIX) {
        var c = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);
        c && !c.suppressPrefixSuffix && (b += Blockly.C.injectId(Blockly.C.STATEMENT_PREFIX,
            c))
    }
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return b + "break;\n";
        case "CONTINUE":
            return b + "continue;\n"
    }
    throw Error("Unknown flow statement.");
};
Blockly.C.math = {};
Blockly.C.math_number = function(a) {
    a = Number(a.getFieldValue("NUM"));
    return [a, 0 <= a ? Blockly.C.ORDER_ATOMIC : Blockly.C.ORDER_UNARY_NEGATION]
};
Blockly.C.math_arithmetic = function(a) {
    var b = {
            ADD: [" + ", Blockly.C.ORDER_ADDITION],
            MINUS: [" - ", Blockly.C.ORDER_SUBTRACTION],
            MULTIPLY: [" * ", Blockly.C.ORDER_MULTIPLICATION],
            DIVIDE: [" / ", Blockly.C.ORDER_DIVISION],
            POWER: [null, Blockly.C.ORDER_COMMA]
        } [a.getFieldValue("OP")],
        c = b[0];
    b = b[1];
    var d = Blockly.C.valueToCode(a, "A", b) || "0";
    a = Blockly.C.valueToCode(a, "B", b) || "0";
    return c ? [d + c + a, b] : ["pow(" + d + ", " + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_single = function(a) {
    var b = a.getFieldValue("OP");
    if ("NEG" == b) return a = Blockly.C.valueToCode(a, "NUM", Blockly.C.ORDER_UNARY_NEGATION) || "0", "-" == a[0] && (a = " " + a), ["-" + a, Blockly.C.ORDER_UNARY_NEGATION];
    a = "SIN" == b || "COS" == b || "TAN" == b ? Blockly.C.valueToCode(a, "NUM", Blockly.C.ORDER_DIVISION) || "0" : Blockly.C.valueToCode(a, "NUM", Blockly.C.ORDER_NONE) || "0";
    switch (b) {
        case "ABS":
            var c = "abs(" + a + ")";
            break;
        case "ROOT":
            c = "sqrt(" +
                a + ")";
            break;
        case "LN":
            c = "log(" + a + ")";
            break;
        case "EXP":
            c = "exp(" + a + ")";
            break;
        case "POW10":
            c = "pow(10," + a + ")";
            break;
        case "ROUND":
            c = "round(" + a + ")";
            break;
        case "ROUNDUP":
            c = "ceil(" + a + ")";
            break;
        case "ROUNDDOWN":
            c = "floor(" + a + ")";
            break;
        case "SIN":
            c = "sin(" + a + ")";
            break;
        case "COS":
            c = "cos(" + a + ")";
            break;
        case "TAN":
            c = "tan(" + a + ")"
    }
    if (c) return [c, Blockly.C.ORDER_FUNCTION_CALL];
    switch (b) {
        case "LOG10":
            c = "log(" + a + ") / log(10)";
            break;
        case "ASIN":
            c = "asin(" + a + ")";
            break;
        case "ACOS":
            c = "acos(" + a + ")";
            break;
        case "ATAN":
            c = "atan(" + a + ")";
            break;
        default:
            throw Error("Unknown math operator: " + b);
    }
    return [c, Blockly.C.ORDER_DIVISION]
};
Blockly.C.math_constant = function(a) {
    return {
        PI: ["Math.PI", Blockly.C.ORDER_MEMBER],
        E: ["Math.E", Blockly.C.ORDER_MEMBER],
        GOLDEN_RATIO: ["(1 + sqrt(5)) / 2", Blockly.C.ORDER_DIVISION],
        SQRT2: ["sqrt(2)", Blockly.C.ORDER_MEMBER],
        SQRT1_2: ["sqrt(1/2)", Blockly.C.ORDER_MEMBER],
        INFINITY: ["Infinity", Blockly.C.ORDER_ATOMIC]
    } [a.getFieldValue("CONSTANT")]
};
Blockly.C.math_number_property = function(a) {
    var b = Blockly.C.valueToCode(a, "NUMBER_TO_CHECK", Blockly.C.ORDER_MODULUS) || "0",
        c = a.getFieldValue("PROPERTY");
    if ("PRIME" == c) return [Blockly.C.provideFunction_("IsPrime", ["int " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(n) {", " if (n <= 1) return false; "," if (n <= 3) return true; ",," if (n%2 == 0 || n%3 == 0) return false;",
         "  for (int i = 5; i*i <= n; i += 6) {", "    if (n % i == 0 || n % (i +2) == 0) {", "      return false;", "    }", "  }", "  return true;", "}"
    ]) + "(" + b + ")", Blockly.C.ORDER_FUNCTION_CALL];
    switch (c) {
        case "EVEN":
            var d = b + " % 2 == 0";
            break;
        case "ODD":
            d = b + " % 2 == 1";
            break;
        case "WHOLE":
            d = b + " % 1 == 0";
            break;
        case "POSITIVE":
            d =
                b + " > 0";
            break;
        case "NEGATIVE":
            d = b + " < 0";
            break;
        case "DIVISIBLE_BY":
            a = Blockly.C.valueToCode(a, "DIVISOR", Blockly.C.ORDER_MODULUS) || "0", d = b + " % " + a + " == 0"
    }
    return [d, Blockly.C.ORDER_EQUALITY]
};
Blockly.C.math_change = function(a) {
    var b = Blockly.C.valueToCode(a, "DELTA", Blockly.C.ORDER_ADDITION) || "0";
    a = Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
    return a + " = (typeof " + a + " == 'number' ? " + a + " : 0) + " + b + ";\n"
};
Blockly.C.math_round = Blockly.C.math_single;
Blockly.C.math_trig = Blockly.C.math_single;
Blockly.C.math_on_list = function(a) {
    var b = a.getFieldValue("OP");
    switch (b) {
        case "SUM":
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]";
            a += ".reduce(function(x, y) {return x + y;})";
            break;
        case "MIN":
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_COMMA) || "[]";
            a = "Math.min.apply(null, " + a + ")";
            break;
        case "MAX":
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_COMMA) || "[]";
            a = "Math.max.apply(null, " + a + ")";
            break;
        case "AVERAGE":
            b = Blockly.C.provideFunction_("mathMean",
                ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  return myList.reduce(function(x, y) {return x + y;}) / myList.length;", "}"]);
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "MEDIAN":
            b = Blockly.C.provideFunction_("mathMedian", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  var localList = myList.filter(function (x) {return typeof x == 'number';});", "  if (!localList.length) return null;",
                "  localList.sort(function(a, b) {return b - a;});", "  if (localList.length % 2 == 0) {", "    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;", "  } else {", "    return localList[(localList.length - 1) / 2];", "  }", "}"
            ]);
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "MODE":
            b = Blockly.C.provideFunction_("mathModes", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(values) {", "  var modes = [];",
                "  var counts = [];", "  var maxCount = 0;", "  for (var i = 0; i < values.length; i++) {", "    var value = values[i];", "    var found = false;", "    var thisCount;", "    for (var j = 0; j < counts.length; j++) {", "      if (counts[j][0] === value) {", "        thisCount = ++counts[j][1];", "        found = true;", "        break;", "      }", "    }", "    if (!found) {", "      counts.push([value, 1]);", "      thisCount = 1;", "    }", "    maxCount = Math.max(thisCount, maxCount);", "  }", "  for (var j = 0; j < counts.length; j++) {",
                "    if (counts[j][1] == maxCount) {", "        modes.push(counts[j][0]);", "    }", "  }", "  return modes;", "}"
            ]);
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "STD_DEV":
            b = Blockly.C.provideFunction_("mathStandardDeviation", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(numbers) {", "  var n = numbers.length;", "  if (!n) return null;", "  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;", "  var variance = 0;",
                "  for (var j = 0; j < n; j++) {", "    variance += Math.pow(numbers[j] - mean, 2);", "  }", "  variance = variance / n;", "  return Math.sqrt(variance);", "}"
            ]);
            a = Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "RANDOM":
            b = Blockly.C.provideFunction_("mathRandomList", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(list) {", "  var x = Math.floor(Math.random() * list.length);", "  return list[x];", "}"]);
            a = Blockly.C.valueToCode(a,
                "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        default:
            throw Error("Unknown operator: " + b);
    }
    return [a, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_modulo = function(a) {
    var b = Blockly.C.valueToCode(a, "DIVIDEND", Blockly.C.ORDER_MODULUS) || "0";
    a = Blockly.C.valueToCode(a, "DIVISOR", Blockly.C.ORDER_MODULUS) || "0";
    return [b + " % " + a, Blockly.C.ORDER_MODULUS]
};
Blockly.C.math_constrain = function(a) {
    var b = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_COMMA) || "0",
        c = Blockly.C.valueToCode(a, "LOW", Blockly.C.ORDER_COMMA) || "0";
    a = Blockly.C.valueToCode(a, "HIGH", Blockly.C.ORDER_COMMA) || "Infinity";
    return ["min(max(" + b + ", " + c + "), " + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_random_int = function(a) {
    var b = Blockly.C.valueToCode(a, "FROM", Blockly.C.ORDER_COMMA) || "0";
    a = Blockly.C.valueToCode(a, "TO", Blockly.C.ORDER_COMMA) || "0";
    return [Blockly.C.provideFunction_("mathRandomInt", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(a, b) {", "  if (a > b) {", "    // Swap a and b to ensure a is smaller.", "    var c = a;", "    a = b;", "    b = c;", "  }", "  return Math.floor(Math.random() * (b - a + 1) + a);",
        "}"
    ]) + "(" + b + ", " + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_random_float = function(a) {
    return ["rand()", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_atan2 = function(a) {
    var b = Blockly.C.valueToCode(a, "X", Blockly.C.ORDER_COMMA) || "0";
    return ["atan2(" + (Blockly.C.valueToCode(a, "Y", Blockly.C.ORDER_COMMA) || "0") + ", " + b + ")", Blockly.C.ORDER_DIVISION]
};
Blockly.C.procedures = {};
Blockly.C.procedures_defreturn = function(a) {
    var b = Blockly.C.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME),
        c = "";
    Blockly.C.STATEMENT_PREFIX && (c += Blockly.C.injectId(Blockly.C.STATEMENT_PREFIX, a));
    Blockly.C.STATEMENT_SUFFIX && (c += Blockly.C.injectId(Blockly.C.STATEMENT_SUFFIX, a));
    c && (c = Blockly.C.prefixLines(c, Blockly.C.INDENT));
    var d = "";
    Blockly.C.INFINITE_LOOP_TRAP && (d = Blockly.C.prefixLines(Blockly.C.injectId(Blockly.C.INFINITE_LOOP_TRAP,
        a), Blockly.C.INDENT));
    var e = Blockly.C.statementToCode(a, "STACK"),
        f = Blockly.C.valueToCode(a, "RETURN", Blockly.C.ORDER_NONE) || "",
        g = "";
    e && f && (g = c);
    f && (f = Blockly.C.INDENT + "return " + f + ";\n");
    for (var k = [], h = 0; h < a.arguments_.length; h++) k[h] = Blockly.C.variableDB_.getName(a.arguments_[h], Blockly.VARIABLE_CATEGORY_NAME);
    c = "function " + b + "(" + k.join(", ") + ") {\n" + c + d + e + g + f + "}";
    c = Blockly.C.scrub_(a, c);
    Blockly.C.definitions_["%" + b] = c;
    return null
};
Blockly.C.procedures_defnoreturn = Blockly.C.procedures_defreturn;
Blockly.C.procedures_callreturn = function(a) {
    for (var b = Blockly.C.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.C.valueToCode(a, "ARG" + d, Blockly.C.ORDER_COMMA) || "null";
    return [b + "(" + c.join(", ") + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.procedures_callnoreturn = function(a) {
    return Blockly.C.procedures_callreturn(a)[0] + ";\n"
};
Blockly.C.procedures_ifreturn = function(a) {
    var b = "if (" + (Blockly.C.valueToCode(a, "CONDITION", Blockly.C.ORDER_NONE) || "false") + ") {\n";
    Blockly.C.STATEMENT_SUFFIX && (b += Blockly.C.prefixLines(Blockly.C.injectId(Blockly.C.STATEMENT_SUFFIX, a), Blockly.C.INDENT));
    a.hasReturnValue_ ? (a = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_NONE) || "null", b += Blockly.C.INDENT + "return " + a + ";\n") : b += Blockly.C.INDENT +
        "return;\n";
    return b + "}\n"
};
Blockly.C.texts = {};
Blockly.C.text = function(a) {
    return [Blockly.C.quote_(a.getFieldValue("TEXT")), Blockly.C.ORDER_ATOMIC]
};
Blockly.C.text_multiline = function(a) {
    a = Blockly.C.multiline_quote_(a.getFieldValue("TEXT"));
    a.includes("\n") && (a = "(" + a + ")");
    return [a, Blockly.C.ORDER_ATOMIC]
};
Blockly.C.text.forceString_ = function(a) {
    return Blockly.C.text.forceString_.strRegExp.test(a) ? a : "String(" + a + ")"
};
Blockly.C.text.forceString_.strRegExp = /^\s*'([^']|\\')*'\s*$/;
Blockly.C.text_join = function(a) {
    switch (a.itemCount_) {
        case 0:
            return ["''", Blockly.C.ORDER_ATOMIC];
        case 1:
            return a = Blockly.C.valueToCode(a, "ADD0", Blockly.C.ORDER_NONE) || "''", a = Blockly.C.text.forceString_(a), [a, Blockly.C.ORDER_FUNCTION_CALL];
        case 2:
            var b = Blockly.C.valueToCode(a, "ADD0", Blockly.C.ORDER_NONE) || "''";
            a = Blockly.C.valueToCode(a, "ADD1", Blockly.C.ORDER_NONE) || "''";
            a = Blockly.C.text.forceString_(b) +
                " + " + Blockly.C.text.forceString_(a);
            return [a, Blockly.C.ORDER_ADDITION];
        default:
            b = Array(a.itemCount_);
            for (var c = 0; c < a.itemCount_; c++) b[c] = Blockly.C.valueToCode(a, "ADD" + c, Blockly.C.ORDER_COMMA) || "''";
            a = "[" + b.join(",") + "].join('')";
            return [a, Blockly.C.ORDER_FUNCTION_CALL]
    }
};
Blockly.C.text_append = function(a) {
    var b = Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
    a = Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''";
    return b + " += " + Blockly.C.text.forceString_(a) + ";\n"
};
Blockly.C.text_length = function(a) {
    return [(Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_FUNCTION_CALL) || "''") + ".length", Blockly.C.ORDER_MEMBER]
};
Blockly.C.text_isEmpty = function(a) {
    return ["!" + (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "''") + ".length", Blockly.C.ORDER_LOGICAL_NOT]
};
Blockly.C.text_indexOf = function(a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.C.valueToCode(a, "FIND", Blockly.C.ORDER_NONE) || "''";
    b = (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "''") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.C.ORDER_ADDITION] : [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_charAt = function(a) {
    var b = a.getFieldValue("WHERE") || "FROM_START",
        c = Blockly.C.valueToCode(a, "VALUE", "RANDOM" == b ? Blockly.C.ORDER_NONE : Blockly.C.ORDER_MEMBER) || "''";
    switch (b) {
        case "FIRST":
            return [c + ".charAt(0)", Blockly.C.ORDER_FUNCTION_CALL];
        case "LAST":
            return [c + ".slice(-1)", Blockly.C.ORDER_FUNCTION_CALL];
        case "FROM_START":
            return a = Blockly.C.getAdjusted(a, "AT"), [c + ".charAt(" + a + ")", Blockly.C.ORDER_FUNCTION_CALL];
        case "FROM_END":
            return a =
                Blockly.C.getAdjusted(a, "AT", 1, !0), [c + ".slice(" + a + ").charAt(0)", Blockly.C.ORDER_FUNCTION_CALL];
        case "RANDOM":
            return [Blockly.C.provideFunction_("textRandomLetter", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(text) {", "  var x = Math.floor(Math.random() * text.length);", "  return text[x];", "}"]) + "(" + c + ")", Blockly.C.ORDER_FUNCTION_CALL]
    }
    throw Error("Unhandled option (text_charAt).");
};
Blockly.C.text.getIndex_ = function(a, b, c) {
    return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c
};
Blockly.C.text_getSubstring = function(a) {
    var b = Blockly.C.valueToCode(a, "STRING", Blockly.C.ORDER_FUNCTION_CALL) || "''",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2");
    if ("FIRST" != c || "LAST" != d)
        if (b.match(/^'?\w+'?$/) || "FROM_END" != c && "LAST" != c && "FROM_END" != d && "LAST" != d) {
            switch (c) {
                case "FROM_START":
                    var e = Blockly.C.getAdjusted(a, "AT1");
                    break;
                case "FROM_END":
                    e = Blockly.C.getAdjusted(a, "AT1", 1, !1, Blockly.C.ORDER_SUBTRACTION);
                    e = b + ".length - " + e;
                    break;
                case "FIRST":
                    e = "0";
                    break;
                default:
                    throw Error("Unhandled option (text_getSubstring).");
            }
            switch (d) {
                case "FROM_START":
                    a = Blockly.C.getAdjusted(a, "AT2", 1);
                    break;
                case "FROM_END":
                    a = Blockly.C.getAdjusted(a, "AT2", 0, !1, Blockly.C.ORDER_SUBTRACTION);
                    a = b + ".length - " + a;
                    break;
                case "LAST":
                    a = b + ".length";
                    break;
                default:
                    throw Error("Unhandled option (text_getSubstring).");
            }
            b = b + ".slice(" + e + ", " + a + ")"
        } else {
            e = Blockly.C.getAdjusted(a, "AT1");
            a = Blockly.C.getAdjusted(a, "AT2");
            var f =
                Blockly.C.text.getIndex_,
                g = {
                    FIRST: "First",
                    LAST: "Last",
                    FROM_START: "FromStart",
                    FROM_END: "FromEnd"
                };
            b = Blockly.C.provideFunction_("subsequence" + g[c] + g[d], ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == c || "FROM_START" == c ? ", at1" : "") + ("FROM_END" == d || "FROM_START" == d ? ", at2" : "") + ") {", "  var start = " + f("sequence", c, "at1") + ";", "  var end = " + f("sequence", d, "at2") + " + 1;", "  return sequence.slice(start, end);", "}"]) + "(" + b + ("FROM_END" == c || "FROM_START" ==
                c ? ", " + e : "") + ("FROM_END" == d || "FROM_START" == d ? ", " + a : "") + ")"
        } return [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_changeCase = function(a) {
    var b = {
        UPPERCASE: ".toUpperCase()",
        LOWERCASE: ".toLowerCase()",
        TITLECASE: null
    } [a.getFieldValue("CASE")];
    a = Blockly.C.valueToCode(a, "TEXT", b ? Blockly.C.ORDER_MEMBER : Blockly.C.ORDER_NONE) || "''";
    return [b ? a + b : Blockly.C.provideFunction_("textToTitleCase", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(str) {", "  return str.replace(/\\S+/g,", "      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});",
        "}"
    ]) + "(" + a + ")", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_trim = function(a) {
    var b = {
        LEFT: ".replace(/^[\\s\\xa0]+/, '')",
        RIGHT: ".replace(/[\\s\\xa0]+$/, '')",
        BOTH: ".trim()"
    } [a.getFieldValue("MODE")];
    return [(Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''") + b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_print = function(a) {
    return "window.alert(" + (Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''") + ");\n"
};
Blockly.C.text_prompt_ext = function(a) {
    var b = "window.prompt(" + (a.getField("TEXT") ? Blockly.C.quote_(a.getFieldValue("TEXT")) : Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''") + ")";
    "NUMBER" == a.getFieldValue("TYPE") && (b = "Number(" + b + ")");
    return [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_prompt = Blockly.C.text_prompt_ext;
Blockly.C.text_count = function(a) {
    var b = Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''";
    a = Blockly.C.valueToCode(a, "SUB", Blockly.C.ORDER_NONE) || "''";
    return [Blockly.C.provideFunction_("textCount", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle) {", "  if (needle.length === 0) {", "    return haystack.length + 1;", "  } else {", "    return haystack.split(needle).length - 1;", "  }", "}"]) + "(" + b + ", " + a + ")", Blockly.C.ORDER_SUBTRACTION]
};
Blockly.C.text_replace = function(a) {
    var b = Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''",
        c = Blockly.C.valueToCode(a, "FROM", Blockly.C.ORDER_NONE) || "''";
    a = Blockly.C.valueToCode(a, "TO", Blockly.C.ORDER_NONE) || "''";
    return [Blockly.C.provideFunction_("textReplace", ["function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle, replacement) {", '  needle = needle.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,"\\\\$1")',
        '                 .replace(/\\x08/g,"\\\\x08");', "  return haystack.replace(new RegExp(needle, 'g'), replacement);", "}"
    ]) + "(" + b + ", " + c + ", " + a + ")", Blockly.C.ORDER_MEMBER]
};
Blockly.C.text_reverse = function(a) {
    return [(Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''") + ".split('').reverse().join('')", Blockly.C.ORDER_MEMBER]
};
Blockly.C.variables = {};
Blockly.C.variables_get = function(a) {
    return [Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.C.ORDER_ATOMIC]
};
Blockly.C.variables_set = function(a) {
    var b = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_ASSIGNMENT) || "0";
    return Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) + " = " + b + ";\n"
};
Blockly.C.variablesDynamic = {};
Blockly.C.variables_get_dynamic = Blockly.C.variables_get;
Blockly.C.variables_set_dynamic = Blockly.C.variables_set;

Blockly.C.variables_declare = function(a) {
      var b = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_ASSIGNMENT) || "0";
    return Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME
        ) + " = " + b + ";\n"
};
Blockly.C.variableC_set=function(a) {
      var b = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_ASSIGNMENT) || "0";
    return Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME
        ) + " = " + b + ";\n"
};

Blockly.C.variableC_get = function(a) {
    return [Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.C.ORDER_ATOMIC]
};

Blockly.C.pointers_declare=Blockly.C.variables_declare;

Blockly.C.pointers_get_C=Blockly.C.variableC_get;

Blockly.C.valueAt = function(block) {
  var value_valueof = Blockly.C.valueToCode(block, 'valueOf', Blockly.C.ORDER_ATOMIC);
  // TODO: Assemble JavaScript into code variable.
  var code = '*'+value_valueof;
  // TODO: Change ORDER_NONE to the correct strength.
  return [code, Blockly.C.ORDER_NONE];
};

Blockly.C.addressOf = function(block) {
  var value_valueof = Blockly.C.valueToCode(block, 'valueOf', Blockly.C.ORDER_ATOMIC);
  // TODO: Assemble JavaScript into code variable.
  var code = '&'+value_valueof;
  // TODO: Change ORDER_NONE to the correct strength.
  return [code, Blockly.C.ORDER_NONE];
};

Blockly.C.array_declare=Blockly.C.variables_declare;

Blockly.C.array=function(a) {
      var b = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_ASSIGNMENT) || "{0}";
      var c="";
      for(var i=1;i<=a.getFieldValue("dimension");i++)
        c+="["+a.getFieldValue("size"+i)+"]";
    return a.getFieldValue("types")+" "+Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) 
    +" "+c+ " = " + b + ";\n"
};

Blockly.C.array_get=function(a){
    var code=Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
    var dimension= a.getFieldValue("dimension");
    for(var i=1;i<=dimension;i++)
    {
        code+="["+a.getFieldValue("size"+i)+"]";
    }
    return [code, Blockly.C.ORDER_ATOMIC];
}

Blockly.C.array_get_baseAddress = function(a) {
    return [Blockly.C.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.C.ORDER_ATOMIC]
};

Blockly.C.variableC_set= Blockly.C.variables_declare;